1. 原型链继承--这种方法会导致所有子类实例共享父类实例的属性，不可传参。本质是通过prototype进行引用
2. 构造函数继承--这种方法不会导致子类实例共享父类实例的属性，可以传参。本质是通过call/apply进行调用。缺点是无法继承父类原型链上的属性和方法，且每次创建子类实例都会创建一遍父类实例
3. 组合继承-- 
    1. 构造函数继承通过调用父类的构造函数来继承父类的实例属性。
	2. 原型链继承将父类的原型对象赋值给子类的原型对象，这样子类的实例就可以访问父类的原型方法。
    3. 在组合继承中，我们将 Child.prototype = new Parent()，即将父类的实例对象赋值给子类的原型。这样做的好处是子类继承了父类原型中的方法。但问题是，父类的实例对象的 constructor 属性指向的是 Parent，而不是 Child。也就是说：Child.prototype.constructor === Parent。这就意味着子类的原型的 constructor 属性不再指向 Child 构造函数，而指向了 Parent 构造函数。这可能会影响一些后续的操作，比如实例化子类对象时，使用 instanceof 操作符时的行为等。
    4. 通过执行 Child.prototype.constructor = Child;，我们将 Child 构造函数重新赋值给 Child.prototype.constructor。这样就修复了原型链上的 constructor 属性，确保它指向子类 Child。
4. 原型式继承--通过原型链继承的方式创建一个新对象，然后对新对象进行扩展，最后返回这个新对象。本质是Object.create()。注意，这里创建的对象是一个新对象，不是父类的实例。所以当给实例赋值时，是给对象新增属性，而不是修改原型链上的属性。
5. 寄生式继承--创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。本质是Object.create()。
6. 寄生组合式继承--通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质是Object.create()


