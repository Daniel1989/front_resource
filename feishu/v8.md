## 垃圾回收

1. v8引擎64位最多使用1.4GB内存，32位最多700MB
2. 原因
    + js单线程机制
    + 为了弥补这个缺陷，游览器引入了web worker线程
    + 垃圾回收耗时，默认需要50毫秒，非增量需要1秒

3. 在JS中声明对象时，该对象的内存就分配在堆中，如果当前已申请内存不够分配，则会继续申请堆内存直到堆大小超过V8的限制


### 具体回收策略（分代式回收机制）

1. 内存结构
    + 新生代：新创建的对象会先放在新生代中
    + 老生代：经过多次垃圾回收后，新生代中的对象会被转移到老生代中
    + 大对象区
    + 代码区
    + map区
2. 新生代，Scavenge算法，牺牲空间换时间
3. 对象晋升
4. 老生代，采样Mark-Sweep算法，牺牲时间换空间(更新的Mark-Compact算法)

### 优化体验
1. 延迟清理
2. 增量式整理

### 避免内存泄漏
1. 避免全局变量
2. 手动清除定时器
3. 少用闭包
4. 解除DOM引用
5. 使用弱引用

## WeakSet 和 WeakMap
1. 普通的 Map 和 Set 会强引用它们的元素，如果我们没有手动清除这些引用，无法让垃圾回收机制及时回收对象。
2. WeakSet 和 WeakMap 使用弱引用，不会阻止垃圾回收机制回收对象。
3. WeakSet 和 WeakMap 不能遍历，也没有 size 属性。
4. WeakSet 只能存储对象，不能存储原始值。
5. WeakMap 的 key 只能是对象，不能是原始值。
6. WeakMap 没有 clear() 方法。
7. WeakMap 和 WeakSet 都没有 forEach 方法。
8. WeakMap 和 WeakSet 都没有 entries() 方法。
9. WeakMap 和 WeakSet 都没有 keys() 方法。
10. WeakMap 和 WeakSet 都没有 values() 方法。
11. WeakMap 和 WeakSet 都没有 forEach 方法。