## 图元
图元就是各种形状

基于 BufferGeometry 的图元是面向性能的类型。 几何体的顶点是直接生成为一个高效的类型数组形式，可以被上传到 GPU 进行渲染。 这意味着它们能更快的启动，占用更少的内存。但如果想修改数据，就需要复杂的编程。

基于 Geometry 的图元更灵活、更易修改。 它们根据 JavaScript 的类而来，像 Vector3 是 3D 的点，Face3 是三角形。 它们需要更多的内存，在能够被渲染前，Three.js 会将它们转换成相应的 BufferGeometry 表现形式。

如果你知道你不会操作图元，或者你擅长使用数学来操作它们，那么最好使用基于 BufferGeometry 的图元。 但如果你想在渲染前修改一些东西，那么 Geometry 的图元会更好操作。

举个简单的例子，BufferGeometry 不能轻松的添加新的顶点。 使用顶点的数量在创建时就定好了，相应的创建存储，填充顶点数据。 但用 Geometry 你就能随时添加顶点。

## 文字
文字生成网格前需要先加载3D字体数据，数据的加载是异步的，所以在尝试创建几何体前需要等待。通过将字体加载 Promise 化。

Three.js 创建的文字的旋转中心在左边。 变通的方法是要求 Three.js 计算几何体的边界框。然后我们可以对边界框调用 getCenter，将网格位置对象传给它。 getCenter 将盒子的中心值复制进位置对象。 同时它也返回位置对象，这样我们就可以调用 multiplyScalar(-1) 来放置整个对象，这样对象的旋转中心就是对象的中心了

Points 和 LineSegments 类似，它需要一个 Geometry 或者 BufferGeometry，但每个顶点都绘制一次，而不是每条线。 要使用，你需要传入 PointsMaterial，它需要一个代表点多大的 size。

如果你想让点无视和摄像机的距离，始终保持相同大小，可以通过将 sizeAttenuation 设置成 false 将其关闭。