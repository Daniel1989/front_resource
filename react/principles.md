1. 问题的关键是解决cpu瓶颈和io瓶颈，而落到实现上，则需要将同步更新变为可中断的异步更新
2. react15没有scheduler，只能是一起更新，所以会导致页面卡顿
3. react16引入了scheduler，将更新任务分为不同的优先级，优先级高的任务会中断优先级低的任务，从而保证页面的流畅性
4. 任务调度与优先级控制
    1. 通过Lane模型为不同更新任务分配优先级，确保关键交互（如用户输入）优先处理，非紧急任务（如界面过渡）延后执行
        1. 紧急更新（Urgent updates）：用户点击、输入等交互行为，对应高优先级Lane（如SyncLane: 0b
        2. 过渡更新（Transition updates）：界面切换、数据加载等，对应低优先级Lane（如TransitionLane）
    2. 优化渲染性能
        1. 减少页面阻塞
            1. 高优先级任务（如用户输入）直接触发同步渲染，低优先级任务通过时间切片（Time Slicing）分批次执行，避免主线程长时间阻塞
        2. 增量渲染
            1. 低优先级更新可被中断并重新调度，确保用户感知的高优先级操作始终流畅
    3. 动态调整优先级
        1. 根据事件类型动态分配Lane
            1. 用户交互事件（如onClick）触发高优先级更新
            2. 异步数据更新（如useEffect）默认使用较低优先级
    4. 组合处理更新
        1. 通过位运算支持多优先级组合判断
            1. 合并更新：将多个Lane合并（如0b01 | 0b10 = 0b11），表示需同时处理两类优先级任务
            2. 优先级筛选：通过updateLanes & renderLanes快速判断当前需处理的更新类型
    5. 避免资源浪费
        1. 中断机制：低优先级任务执行过程中若出现高优先级任务，立即中断并重新排队，减少无效渲染
        2. 批量更新：相同优先级的更新合并处理，降低重复渲染频率
5. 时间分片
    1. 阻塞的是生产Fiber的过程，但是提交给DOM时一定是完整的
    2. 时间分片是指将一个大的任务分割成多个小任务，每个小任务（5ms左右）执行完后，检查是否有更高优先级的任务需要执行，如果有则先执行更高优先级的任务，否则继续执行下一个小任务。这样可以保证高优先级任务的及时响应，同时也不会阻塞主线程，保证了页面的流畅性
    3. 每个任务执行完毕后，立即将主线程交给游览器，保证用户操作的及时响应，比如点击，输入
